\chapter{Epithelium}
\label{chap:Epithelium}
\section{About Epithelium}
Here I present my implementation of the Honda-Nagai Model for epithelial tissue development as the simulation software called \emph{Epithelium}. The software is easy to install, takes up less than 50Mb, comes in parallel and non-parallel versions (Version 2.0.0, Version 1.0.0) and has very few dependencies. \emph{Epithelium} allows users to specify all parameters of interest in easily modifiable text configuration files, and can generate data for animations of epithelial tissue development as well as useful plots of important variables. 

\begin{figure}
\centering
\includegraphics[width=\textwidth]{../diagrams/BeforeAfter.png}
\caption[Cells before and after dynamics]{Cells before (left) and after (right) dynamics. The colored cells highlight cells with parameters different from the globally assigned values.}
\label{fig:beforeafter}
\end{figure}

The source code is highly modularized and allows for ambitious users to easily extend it to meet their needs. For example, alternate numerical integrators can easily replace the existing one, new mesh generators can replace the square mesh I have developed, and all data is output in space-separated formats which users with scripting language experience can transform to serve as input into the graphical utilities of their choice. In addition, the cell and coordinate classes are well documented and can be extended to output new data. Figure~\ref{fig:beforeafter} provides a taste of what the most basic installation of \emph{Epithelium} can do, showing a mesh of cells before and after equilibration.

\section{Sample Configuration Files}
The typical user will not want to modify source code, but would prefer to have a simple interface for changing simulation parameters. In this section we will explore in depth what the user interface looks like in terms of the three main configuration files, \texttt{config.txt}, \texttt{parameters.txt} and \texttt{change\_mesh.txt}.
\subsection{Simulation Settings, the Initial Mesh, and config.txt}
In this file, the user can specify some global properties about the mesh, and some important quantities for how the simulation will proceed. The \texttt{dimension} of the mesh refers to the number of cells along a given axis in a square mesh, and the \texttt{max\_step\_size} is the largest step the adaptive time stepping of the numerical integrator may take. OFF is the file format given to the plotting program \textbf{geomview} to plot the mesh and the user can specify how often the code prints an image with the \texttt{frequency} parameter, but it must be a multiple of ten. More closely spaced images can be generated by using a smaller integration step size. The \texttt{delta} parameter on line 5 specifies how close two vertices must be to force a T1 swap to occur.

The default setting of \emph{Epithelium} creates initial conditions by drawing an equilibrium mesh of hexagons, and then perturbing it.
The \texttt{swap length}, \texttt{upper bound}, and \texttt{max swaps} parameters are used for performing these random transformations, and if all are set to zero, the simulation will not alter the tissue. The \texttt{swap length} is the edge length below which a swap is performed, and the \texttt{max swaps} parameter defines the maximum number of random perturbations the code will make to the mesh before starting the simulation. The \texttt{upper bound} is an integer which is the upper bound of the range for a random number generator. A random number generator produces an integer in the range [1:\texttt{upper bound}], and a random T1 swap is performed to some edge of some cell when the random integer is `1'. 

\begin{lstlisting}
13 # Dimension of mesh MUST BE ODD!!!!
0.01 # Maximum step size
1000 # Number of iterations
10 # frequency of OFF file output. Must be a multiple 10!
.1 # delta minimum vertex separation.
1000 # max swaps
1.5 # swap length
2 # upper bound random number generator
1 # Make energy and shape plots? [1/0]
1 # Make a movie in the end? [1/0]
\end{lstlisting}

\subsection{Global Cell Parmeters}
In the \texttt{parameters.txt} file, the user can specify the parameters discussed in Chapter~\ref{chap:intro}. These are the default parameters for all of the cells in the tissue.
\begin{lstlisting}
beta = 3;
lambda = 55;
t_gamma = 1;
t_area = 4.0;
\end{lstlisting}

\subsection{Local Cell Parameters}
While the parameters file allows global control of the mesh, the \texttt{change\_mesh.txt} file allows users to change local properties of the mesh. The first line of the file is for specifying how many cells will have their $\gamma$, $A_0$, $\lambda$, and $\beta$ parameters changed. Note that $P_0$ cannot be changed, as $P_0$ is a function of $A_0$. The subsequent lines are for specifying the cell index and new cell parameter value for each one of these modifications. As can be seen in Figure~\ref{fig:beforeafter}, cells can be color coded by parameter value to highlight these changes to the default settings.
\begin{lstlisting}
2 3 1 1 # num gamma, num area, num lambda, num beta
16 4.0  # gamma
17 5.1  # gamma
3 1.0   # area
4 1.0   # area
10 3.7  # area
1 10    # lambda
90 100  # beta
\end{lstlisting}

\section{Monitoring the Output of Epithelium}
Model parameters are easy to change in \emph{Epithelium}, and a variety of simulations are possible with very minimal effort on part of the user. Figure~\ref{fig:g1}-~\ref{fig:g3} show the output from \emph{Epithelium} for several parameterizations, including changes to the target area, and the $\beta$, $\gamma$, and $\lambda$ values, and can be compared to the output of the original Honda-Nagai model in Figure~\ref{fig:fourgraphs}. Each of the plots show the decreasing energy in the mesh over time and the equilibrium distributions of cell areas, perimeters, and shapes. There is very little variation between the plots - this is an essential property of the Honda-Nagai Model~\cite{HondaNagai} that the introduction of cell proliferation and an unbounded mesh could change.  

\begin{figure}
\centering
\includegraphics[width=\textwidth]{../diagrams/energyComp.png}
\caption[Energy graphs.]{Energy graphs. Showing the decreasing energy in a mesh for two parameterizations. (left)$A_0 = 4.0$; $\beta = 0.0$; $\gamma = 1.0$; $\lambda = 5.0$. Many jumps due to inconsistencies that result from the T1 swaps. (right) $A_0 = 4.0$; $\beta = 5.0$; $\gamma = 1.0$; $\lambda = 1.0$. Energy decreases smoothly.}
\label{fig:g1}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{../diagrams/perimComp.png}
\caption[Equilibrium area graphs]{Equilibrium distribution of cell perimeters after dynamics. (left) $A_0 = 3.0$; $\beta = 1.0$; $\gamma = 3.0$; $\lambda = 3.0$. (right) $A_0 = 4.0$; $\beta = 5.0$; $\gamma = 1.0$; $\lambda = 1.0$.}
\label{fig:g2}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{../diagrams/areaComp.png}
\caption[Equilibrium area graphs]{Equilibrium area after dynamics. (left) $A_0 = 4.0$; $\beta = 5.0$; $\gamma = 1.0$; $\lambda = 1.0$. (right) $A_0 = 4.0$; $\beta = 0.0$; $\gamma = 1.0$; $\lambda = 5.0$.}
\label{fig:g3}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{../diagrams/shapeComp.png}
\caption[Equilibrium distribution of cell shapes.]{Equilibrium distribution of cell shapes after dynamics. (left) $A_0 = 3.0$; $\beta = 1.0$; $\gamma = 3.0$; $\lambda = 3.0$. (right) $A_0 = 4.0$; $\beta = 5.0$; $\gamma = 1.0$; $\lambda = 1.0$.}
\label{fig:g4}
\end{figure}

\section{The Design of \emph{Epithelium}}
The technical details of how a vertex dynamics model can be effectively implemented are not explained in great depth in the literature\footnote{\cite{ChasteMain} is an exception, but is rather advanced.}. I will fill this intellectual void in the section that follows by presenting a detailed look at the data structures and algorithms needed for the programming of the Honda-Nagai Model. It is fitting to start with a very high-level overview of the structure of the code.

\subsection{[Highly Simplified] Pseudocode}
Here I will briefly outline how the code works. All of the functions are explained in some detail later in this chapter.
\begin{lstlisting}
mesh_variables <- read_configs()
mesh <- make_mesh()
random_alterations(mesh)
copy(mesh, rotate_mesh)
rotate(rotate_mesh)
print(simulation_info) # So the user can verify all parameters.
for i = 1:num_iters
   if(iter%print_freq == 0)
      print(OFF_file)
   temp_mesh = NagaiHondaForce(mesh) 
   temp_rotate_mesh = NagaiHondaForce(rotate_mesh)
   mesh <- mesh + temp_mesh
   rotate_mesh <- rotate_mesh + temp_rotate_mesh
   performT2(mesh)
   performT1(mesh)
   performT2(temp_rotate_mesh)
   performT1(rotate_mesh)
rotate_back(rotate_mesh)
compare_mesh(mesh, rotate_mesh)
print(graphics and error analysis)
\end{lstlisting}

\subsection{Classes}
\label{sec:class}
\emph{Epithelium} has a partially object oriented design. The cell and vertex classes organize the data into meaningful pieces.
\begin{itemize}
\item The {\color{red} Cell} class contains a number of useful functions and data members to make the code easy to read and understand. All cell information could have been stored in arrays, but the OO structure makes the code more readable. All cells know their index, which vertices make them up, they are able to calculate their area and perimeter, can modify their constituent vertices, can tell you whether or not they contain a specific vertex, and can print out a graphical, color coded representation of themselves to an OFF file. For information about further functionality of the cell class, the reader is referred to the \texttt{cell.cpp} file in the source code. For information about downloading the source code, see appendix A.
\begin{lstlisting}
public:
 cell(int index, vector<int> AssociatedVertices,\
       double target_area = t_area, double gamma = t_gamma)
 {	
   assert(index >= 0);
   m_AssociatedVertices = AssociatedVertices;
   m_index = index;
   m_target_area = target_area;
   m_target_perimeter = sqrt(pi * m_target_area);
   m_gamma = gamma; 
 }
	
 cell(){} // Default constructor
	
 vector<int>GetVertices(){return m_AssociatedVertices;};
 int GetIndex(){return m_index;};
 void SetIndex(int index){m_index = index;};
 void SetTargetArea(double area){m_target_area = area;};
 double GetTargetArea(){return m_target_area;};
 double GetTargetPerimeter(){return m_target_perimeter;};
 double ComputeArea(double * X, double * Y);
 double ComputePerimeter(double * X, double * Y);
 void PrintCell(ofstream &OffFile);
 int ContainsVertex(int index);
 void SetGamma(double gamma){m_gamma = gamma;};
 double GetGamma(){return m_gamma;};
 void InsertVert(int v1, int v2);
 void EraseVert(int index)
 {
   vector<int>::iterator it = find(m_AssociatedVertices, index); 
   m_AssociatedVertices.erase(it);
 };
 void ReplaceVert(int before, int after)
 {
   vector<int>::iterator it = find(m_AssociatedVertices, before); 
   *it = after;
 };
 void SetVertices(vector<int> vertices)
 {
   m_AssociatedVertices = vertices;
 };
 int GetNumSides(){return m_AssociatedVertices.size();};
private:
 vector<int> m_AssociatedVertices; // Stored counterclockwise
 int m_index;	
 double m_target_area;
 double m_target_perimeter;
 double m_gamma;
};

\end{lstlisting}

\item The {\color{green} Vertex} class stores the index of a vertex, and 
whether or not the vertex will move during the integration. While a 
vertex object does not store the location of the vertex, it tells the 
simulator whether or not a vertex is on the border of a mesh and, if it 
is not, it is allowed to move. It was a design choice that 
\emph{Epithelium} be able to run three popular types of meshes, those 
with border, those without, and those that cover a surface.  Another 
benefit of the vertex class is that is allows users to easily extend 
the code to include forces acting on individual vertices, and to 
specify other types of vertices besides interior and exterior. The 
vertex class could be extended to include a member function such as 
activeMigration(), or any number of interesting functions.
\begin{lstlisting}
class vertex
{
public:
  vertex(int idx, bool t) : index(idx), IsInner(t){};
  vertex(){index = -1; IsInner = 0;};
  int index;
  bool IsInner;
  inline bool operator==(const vertex& rhs)
  {return index == rhs.index;};
};
\end{lstlisting}
\end{itemize}

\section{Parameter Implementations}
The $P_0$ and $\gamma$ parameters have no explicity stated value in the Honda-Nagai Model, and a number of reasonable choices about their implementation could be made. 

Recall that the membrane surface energy term $U_S$ is given by
\begin{equation}
U_S = \beta(P - P_0)^2
\end{equation}
 where $P$ is the cell perimiter, $P_0$ is a target perimeter, and $\beta$ is some positive constant. Furthermore, note that the target perimeter is dependent upon the target area. There are several ways to assign a target perimeter $P_0(A_0)$ as a function of the target area. One obvious choice is to assume the cell tends to become a circle in the absence of resistance, and then solve a system using the equations for area and perimeter of a circle, giving $P_0 =2\sqrt{\pi A_0}$. Another easy choice would be to assume the equilibrium epithelial cell shape is a hexagon, and then compute the target perimeter using the equations for the perimeter and area of a regular hexagon. The correct form for the target perimeter term is not specified in~\cite{HondaNagai}, so I take the circle approach, as done in~\cite{ChasteMain}.

The second choice that was forced upon us was the specification of the $\gamma$ term in the cell-cell adhesion potential. Recall that cell-cell adhesion energy $U_A$ is given by
\begin{equation}U_A = \displaystyle\sum\limits_{j = 1}^{n}\gamma_{j}d_{j}\end{equation}
where  $\gamma$ is some constant depending upon the nature of the two cells interacting on a boundary. The $\gamma$ term could have been implemented in various ways. I have chosen to assign a ``stickiness'' to each cell, and then the $\gamma$ term is calculated as the average stickiness of two interacting cells. This is the approach taken in the molecular dynamics software CHARMM for handling pair interactions of atoms~\cite{CHARMM}.

The $\gamma$ parameter could also have been implemented as something of the form:
\[  \gamma_{ij} =  \left\{
\begin{array}{ll}
      c_0 & \textrm{if the cells $i$ and $j$ are of the same type} \\
      c_1 &  \textrm{if the cells are of compatible type}\\
      c_2 & \textrm{if the cells are of incompatible type} \\
\end{array} 
\right. \]
And the resulting dynamics might have been quite different. Neither form was explicitly stated in the original Honda-Nagai paper~\cite{HondaNagai}, so I had to make a choice about the implementation.

\section{A Relational Database}
There is one other major idea behind the design of \emph{Epithelium}. A 
popular way to store data since the advent of the relational database is in groups of tables which are connected via \emph{keys}. This type of database is popular for reasons which will become apparent by means of a simple example. 

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{../diagrams/relationaldb.png}
\caption[An example of a relational database.]{An example of a relational database. Notice how implementation (a) requires more storage space than (b).}
\label{fig:rdb}
\end{figure}

Consider a business which sells a number of products, and wants to keep 
track of their customers, the customer's orders, the customer's 
addresses, and information about the products ordered. A wasteful way 
to store this data is to create a large table in which the first column 
is for customer names. Next to every customer's name is the customer's 
address, and next to the customers address is the customer's order 
number. Next to the customer's order number is an item in that order, 
and next to each item ordered is the item information. This method of 
storing data is terribly redundant, because for each order with more 
than one item you would have the unnecessary storage of the orderid, and of all 
the customer information. Consider Figure~\ref{fig:rdb}a for an illustration of the concept.
A better idea is to break this data up into several tables which 
together define a \emph{schema}. By defining an appropriate schema, we can minimize the redundancy of information, and extract specific subsets of data in a cache-efficient way. Consider Figure~\ref{fig:rdb}b for an illustration of the concept.

\begin{figure}[ht]
\centering
\includegraphics[width=0.5\textwidth]{../diagrams/ds.png}
\caption{Data structure used for storing data in a non-redundant form.}
\end{figure}

The \emph{Epithelium} data structure is a schema made up of the \texttt{simulationCells}, \texttt{vertexList}, \texttt{X}, \texttt{Y}, \texttt{tempX} and \texttt{tempY} tables. The cell and vertex tables are implemented as 1D \texttt{std::vectors} of cell and vertex indices, whereas the position tables are implemented as low-level 1D arrays for ease of passing these structures to CUDA C functions in the parallel implementation of the software. The cells can extract coordinate information from the \texttt{vertexList} table via the \emph{index} key, and the \texttt{coordinateList} can access the position information from the \texttt{X} and \texttt{Y} arrays via their own \emph{index}. The temporary X and Y arrays store temporary position information about the vertices before the mesh positions are updated. This choice saves both memory and time because no data is stored redundantly. The coordinate information of a vertex is not stored in every cell that contains it, thus huge data structures need not be passed around when only a small portion of data is required. When updating vector locations, only the position and temporary positions are passed to a function instead of the entire mesh. 

\section{Initial Mesh Design}
The hex\_mesh() function generates an $n\times n$ mesh of cells, where the 
dimension represents the number of cells touching the boundary in 
either axial direction. Figure ~\ref{fig:mesh} shows the default mesh 
used by \emph{Epithelium}, with the cell ids and vertex indices labelled. After a sheet of cells is generated by 
\texttt{hex\_mesh()}, the tissue is perturbed by performing random 
T1 swaps on edges of the mesh, and then by perturbing the locations of a select 
number of vertices.

\begin{figure}
\centering
\includegraphics[width=0.7\textwidth]{../diagrams/vert_mesh.png}
\caption[A 5x5 Hexagonal Mesh.]{A typical mesh generated by \emph{Epithelium}. A 5x5 hexagonal mesh is shown with  
cell indices written in the cells and vertex indices on red bars.}
\label{fig:mesh}
\end{figure}

\section{Moving the Vertices}
While the data structures behind \emph{Epithelium} are important to understand, the most fundamental idea behind a vertex dynamics model is how the vertices in a tissue are moved.  \emph{Epithelium} transforms the tissue by looping over all of the vertices, computing the force acting on each vertex, and then computing a displacement with the Forward Euler Method (equation~\ref{en:fem}. 

\begin{equation}
\label{en:fem}
r_i^{t+1} = r_i + \Delta t\frac{dr_i}{dt}
\end{equation}

In their original paper, H. Honda and T. Nagai described the use of a Modified Runge Kutta Method\cite{HondaNagai} to move the vertices, but this method would result in vastly more computations per each time step. A similar approach has been used in ~\cite{WO, ChasteMain}. 

A displacement is calculated and stored in the temporary X and Y arrays. No vertex is permitted to move more than one half of the minimum $\delta$ separating vertices (the $\delta$ under which a T1 swap will occur) during an integration. By imposing this restriction we are ensuring that we will not miss the event of two vertices coming critcally close and a T1 swap occurring. Also, this prevents vertices from passing each other and invalidating the mesh. To ensure that no vertex moves too much, we verify each displacement as we put it in the temporary X and Y arrays. If a displacement is too large, then the entire array of temporary displacements is erased, the time step is halved, and we begin the integration again. For this reason, we could label the integrator as `fault tolerant'.

Another important aspect of the numerical integration is that cell and vertex information must be processed in counterclockwise order. When we are integrating a vertex $i$, \emph{Epithelium} first searches in the \texttt{simulationCells} vector for a cell which contains $i$, and then the finds the next vertex $ip1$ in that cell's \texttt{m\_AssociatedVertices}\footnote{\texttt{m\_AssociatedVertices} is the container for the vertices making up a cell. See section~\ref{sec:class}.}. This step gives us an oriented edge. Some other cell contains that edge if it contains both of the vertices, and, if that cell exists, it must be clockwise from the first. The cells are stored in the reverse order of which they are uncovered by this algorithm before the integration of the equation of motion for $i$ starts. This is a very expensive step ($O(n^3)$) in the computation, and ought to be optimized.

\begin{figure}[hr]
\centering
\includegraphics[width=0.5\textwidth]{../diagrams/rotate.png}
\caption{A rotated mesh for error analysis.}
\label{fig:rotate}
\end{figure}

\section{Error Tolerance of the Algorithm}
\emph{Epithelium} outputs an error measurement at the end of a simulation to give the user a sense of the numerical stability of the code. \emph{Epithelium} offers the user the option to run two simulations at the same time, one on the mesh made by hex\_mesh(), and another on the same mesh which has been rotated 45 degrees (See Figure~\ref{fig:rotate}). In this way, we hope to expose any dynamics which are dependent upon the rounding of floating point numbers. Then, at the end of a simulation, the rotated mesh is rotated back and corresponding vertices are compared by index using the Euclidean norm. In practice a number near $\epsilon_{mach}$ is returned as the maximal Euclidead distance between corresponding vertices.

\section{Embarassing Parallelism and CUDA}
The numerical integrations and the vertex location updates exhibit what Cleve Moler describes as ``embarassing parallelism''. Computing the displacement of vertex \emph{a} does not depend upon the computation of the displacement of vertex \emph{b} during a given time step. Similarly, the vertex locations can all be updated in parallel since the update is simply a vector sum operation of the X and Y arrays with the temporary X and Y arrays, respectively. \emph{Epithelium} employs several parallel routines for these types of operations when it is possible. 

A popular hardware choice for parallel programming in last decade has been the NVIDIA GPU, and an extension of the C language called CUDA was developed to allow programmers to send certain portions of C code the GPU for processing. In order to give the reader a better understanding of which portions of an epithelial modeling software can be effectively run on a GPU, a brief introduction to CUDA programming is necessary.

The NVIDIA CUDA-capable GPU is a collection of many small, weak processors packed very densely on a graphics card. The chips are so closely packed that each simple microprocessor has only a few registers in which to store memory, but all of the microprocessors have access to a larger global memory stored on the side of the card. One key to effective CUDA programming is to give the microprocessors small bits of data upon which they perform many calculations with minimal need to talk to global memory. Another fundamental trick to efficient GPU programming is to coalesce memory accesses so that neighboring processors grab data from nearby regions in global memory during every global memory transaction. The CUDA hardware has been optimized such that when neighboring processors on the graphics card attempt to access memory addresses \texttt{arr[0]} and \texttt{arr[1]}, the transaction is essentially melded into one operation and performed smoothly. On the other hand, when two neighboring processors attempt to get data from \texttt{arr[0]} and \texttt{arr[100]}, the hardware strains to gather information from different sectors of the global memory and send these large chunks of memory to the local processors~\cite{Udacity}. The demand that memory accesses be coalesced has been the single impeding factor in the full CUDA parallelization of \emph{Epithelium}, for while the numerical integrations are \emph{theoretically} parallelizable, data from several arrays is used in calculating the force on a vertex.

Nevertheless, CUDA was employed for two obviously parallel tasks, and for one slightly more sophisticated one. The sum of the position arrays and the temporary position arrays was done with a simple vector sum, and the rotation of the mesh for error detection was performed by multiplying the coordinates of each vertex in the mesh by the rotation matrix:
\[ \left( \begin{array}{cc}
\cos\theta & -\sin\theta \\
\sin\theta & \cos\theta 
\end{array} \right)\] 
CUDA was also employed for the slightly challenging task of calculating the error between the non-rotated and rotated meshes by first subtracting the position arrays of the rotated mesh from the position arrays of the non-rotated mesh, at which point the calculated differences are then stored in $dX$ and $dY$. Next, the Pythagorean theorem is used to calculate the distances between the coordinates, and these lengths are stored in the $dist$ array. The maximum distance is then extracted from this array in $log(N)$ time by comparing neighboring elements and discarding the smaller one until only one element remains, giving the maximum $||*||_2$ error in the mesh.

\section{Computing Topological changes.}
Now that we have covered the way that the equation of motion is integrated, we move on to how the topological changes are implemented in \emph{Epithelium}.  

\subsection{The T2 swap.}
The \texttt{PerformT2s()} function looks at every triangular cell in the mesh and checks the edge lengths. If the cell has a critically small edge, then the cell is deleted from the mesh. The centroid of the cell is calculated, and this becomes the vertex representing the collapsed triangle. Then, one of the three constituent vertices has its position updated to the centroid coordinate and any cell which previously bordered the triangular element has both vertices related to the triangle deleted from \texttt{m\_AssociatedVertices}. Finally, the centroidal vertex is inserted in the position of the deleted vertices. It is important to note that the \texttt{PerformT2s()} function must be called before the \texttt{PerformT1s()} function to make sure that all offending triangular elements are deleted before we perform the T1 swaps. The T1 swap requires four vertices to be performed correctly, as explained in the next section.

\subsection{The T1 Swap}
The \texttt{PerformT1s()} function loops over all of the cells in the mesh, and checks the edge lengths in each cell. If an edge is critically small (less than $\delta$), then a T1 swap must occur. The first step taken by the PerformT1s() function is to find all of the cells and vertices involved in the swap.

Since the critically small edge was detected by looping over all the cells in the mesh and checking their edges, we can identify the cell that initiated the swap (let's refer to is as $c1$). There is another cell in the mesh which contains the offending edge, and we can call that cell $c2$. Since $c1$ contains at least four vertices, then we can label the four vertices of interest, $im1$, $i$, $ip1$, $ip2$. $i$ and $ip1$ are the vertices bounding the small edge, $im1$ is the vertex before $i$, and $ip2$ is the vertex coming after $ip1$(figure~\ref{fig:t1pdf}).

Given these indices for the vertices, we can find the other cell in the mesh which contains $ip1$ and $ip2$, which we call $c3$. Finally, we locate the cell containing $im1$ and $i$, and call this cell $c4$. Now that all of the cells are located, we proceed to perform the T1 operation during the course of which $c1$ and $c2$ will cease to be neighbors and $c3$ and $c4$ will become neighbors. 

The midpoint $mp$ of the edge ($i$, $ip1$) is calculated and a perpendicular bisector $b$ is drawn through it. The centroid ($CN1$) of $c1$ is calculated and the vector pointing from $m$ to $CN1$ defines the direction in which a new vertex should be placed. Next, the centroid ($CN2$) of $c2$ is calculated, and the vector pointing from the $m$ to $CN2$ defines the direction in which the other new vertex should go. This could have been implemented in several ways, but in \emph{Epithelium} $ip1$ is deleted from $c2$ and placed along $b$ in the direction indicated by $CN1$ at a distance $\delta$ from the midpoint. Vertex $i$ is deleted from $c1$ and is moved a distance $\delta$ along $b$ in the direction indicated by $CN2$.

Before the function ends, $i$ is inserted after $ip1$ in $c3$ and $ip1$ is inserted after $i$ in $c4$. Figure~\ref{fig:t1pdf} offers a visual aid to understanding the swap. The entire operation is easy to implement thanks to the counterclockwise storage of vertices.

\begin{figure}
\centering
\includegraphics[height=0.5\textheight, keepaspectratio]{../diagrams/t1pdf.png}
\caption[Implementation of a T1 swap.]{The implementation of a T1 swap. The vertices are labeled with indices corresponding to their local indices in cell $c1$. Notice how before the swap(top) $c1$ and $c2$ are neighbors, but after the swap $c3$ and $c4$ have become adjacent.}
\label{fig:t1pdf}
\end{figure}

\section{Dependencies}
Our discussion of \emph{Epithelium} would not be complete without a discussion of software dependencies. In contrast to the large number of packages required to run other epithelial tissue simulators, the non-parallelized version of \emph{Epithelium} requires only Python 2.7~\footnote{The code was not tested with Python 3. Even if the code compiles with 3, there is no guarantee that the code will continue to work, as Python 3 is evolving.}, a C++11 or C++14 compiler, and BASH. Python and BASH handle some file I/O operations of the program, and are used to make plots and format data for the animations. Indeed, one could run \emph{Epithelium} and generate OFF files of the tissue with only the specified C++ compiler installed, but several error messages would be generated as the program searchs for the scripting languages.

In order to visualize the output of Epithlium you must have geomview and ImageMagick installed to plot the meshes and to convert the .rgb image files to a .gif animation. All of these programs, languages, and compilers are free and so popular\footnote{Except geomview. Indeed, another program could be used for visualization, but I am most comfortable with this program for quick plotting tasks.} that they already installed by default on many Mac and Linux computers. 

The parallel version of \emph{Epithelium} has all of the above dependencies, plus the requirement of the nvcc CUDA compiler and a CUDA capable GPU. 

\begin{figure}
\centering
\includegraphics[width=0.5\textwidth]{../diagrams/v.png}
\caption{The runtime does not scale as the number of vertices.}
\label{fig:v}
\end{figure}


\begin{figure}
\centering
\includegraphics[width=0.5\textwidth]{../diagrams/vsqrd.png}
\caption{The runtime does not scale as $|V|^2$.}
\label{fig:v2}
\end{figure}


\section{Complexity}
Wrapping up our discussion of \emph{Epithelium}, we will look at the time complexity of the algorithm. We will consider the ideal case in which the step size and parameters have been chosen such that the step size will not need to be adapted, and we run the algorithm for 200 time steps.
Then, we will divide the runtime by the number of vertices being moved.

For each vertex in the mesh, the displacement is calculated in constant time in the \texttt{AreaForce.hpp} and \texttt{PerAdhForce.hpp} files, and then each vertex is updated in constant time in the \texttt{MoveVerts()} function. The T1 swap will also be linear in  the number of vertices, as the \texttt{PerformT1s()} function looks at each edge in the mesh twice (hence each vertex 6 times, since a vertex is connected to three edges) and will perform constant-time work on the vertex when an edge is too small. The T2 swap is linear in the number of cells, because T2 swaps are rare, and the first step in the T2 swap is to check if a cell is a triangle. 
Given these facts, we think that the integration and position updates ought to scale with the number of vertices in the mesh.

 To verify the complexity of the algorithm, we use an unperturbed mesh and run the simulation for various numbers of vertices. We make sure that the time step is never halved by choosing small parameter values and aborting whenever $\Delta t$ is halved. Unfortunatlely, the runtime does not scale as the number of vertices $|V|$, likely due to the expensive memory transactions involved in the computations of displacements (Figures~\ref{fig:v},~\ref{fig:v2}). A more efficient datastructure is needed, therefore, to parallelize \emph{Epithelium} as well as to make the serial version more memory efficient.
